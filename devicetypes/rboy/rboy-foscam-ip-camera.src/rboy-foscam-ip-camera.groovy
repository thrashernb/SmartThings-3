/* **DISCLAIMER**
 * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
 * 1. the software will meet your requirements or expectations;
 * 2. the software or the software content will be free of bugs, errors, viruses or other defects;
 * 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
 * 4. the software will be compatible with third party software;
 * 5. any errors in the software will be corrected.
 * The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
 */ 
 
def clientVersion() {
    return "03.04.01"
}

/**
 * Foscam/Tenvis IP Camera
 *
 * Base from skp19, Enhanced and bugfixed by RBoy
 * Changes Copyright RBoy, redistribution of any changes or modified code is not allowed without permission
 * Change log:
 * 2017-1-14 - (v3.4.0) Added support for PIR and Motion options and the Amba Chipset/C2, R2, FI9900P camera, added support for cloud uploading, added support for showing error in communication with camera
 * 2016-12-2 - Fixed issue with password special characters in RTSP streams
 * 2016-11-30 - Improved text description
 * 2016-11-22 - Fixed issue with DNS service not working
 * 2016-11-5 - Added support for code version reporting
 * 2016-10-24 - Improved rate limit to block runaway loops, added ability to check for updates
 * 2016-10-7 - Rate limit number of pictures taken to 20 per 60 seconds on request from ST staff
 * 2016-9-6 - Added support for sound detection and clarified setup settings
 * 2016-7-26 - Clarified import of JsonSlurper
 * 2016-7-17 - Clarified IP input is hostname and not URL
 * 2016-7-5 - Clarification, hostnames are only for public DNS hostnames not local LAN
 * 2016-5-24 - Invoke refresh if user has not initialized camera after initial install and started video streaming
 * 2016-5-24 - Disabled imageDataJpeg attribute and storage for now on ST's request
 * 2016-5-24 - Comment out the updated() function since it's causing random issues with some users and being called randomly
 * 2016-5-17 - Clarified RTSP defaults in preferences
 * 2016-4-29 - Take care of bad camera firmware creating malformed XML strings
 * 2016-4-28 - Optimized layout of UI and button for video streaming
 * 2016-4-25 - Only enable mainStream h.264 (but activate subStream MJPEG for SmartTiles) for now since subStream MJPEG has issues with compatibility with ST Phone and subStream h.264 will break SmartTiles
 * 2016-4-23 - Summary is the default tile to show the motion detection on / off in the list of things
 * 2016-4-23 - Added separate RTSP port for C1 and other HD cameras, fix for switching profiles
 * 2016-4-23 - Fix for special characters in the password, fix for changing profiles
 * 2016-4-22 - Provided an option for enabling MJPEG cameras which also supports SmartTiles
 * 2016-4-19 - Added support for Video streaming for HD and SD cameras with Hi and Low res stream options
 * 2016-4-12 - Allow for no password in login (not a recommended practice but allow for it)
 * 2016-4-2 - Updated color for Auto LED off to light blue
 * 2016-4-2 - Fix for left/right/up/down direction when using HDCameras and Flip/Mirror (camera auto compensates)
 * 2016-4-2 - Changed message on motion detection to Motion instead of Alarm to emulate a motion sensor (and blue color)
 * 2016-3-15 - Changed imageDataJpeg to a Base64 string instead of UTF-8 to make it compatible with SmartTiles
 * 2016-3-15 - Fixed updated function
 * 2016-3-12 - Added support for imageDataJpeg attribute to report the JPEG picture as a UTF-8 String
 * 2016-2-28 - When using public hostnames don't convert to public IP, support for reverse proxies
 * 2016-2-14 - Removed unnecessary notifications from activity log
 * 2016-2-6 - Fixed refresh on configuration
 * 2016-2-2 - Add initialization on settings update
 * 2016-1-13 - Fix for "Content is not allowed in prolog" error (due to BOM) in older SD cameras
 * 2016-1-6 - Added option to manually enter detection area in the settings (no leading or trailing & required)
 * 2016-1-2 - Improved layout of buttons
 * 2015-10-11 - Added support to check for SD camera wrong username/password authorization errors
 * 2015-10-3 - Added support to fallback and retry if httpGet fails with hubAction
 * 2015-10-2 - Improve support for public ip address and improved speed of response for picture taking
 * 2015-9-30 - Fixed issue with special characters not working in username and password and preset names
 * 2015-9-30 - Improved settings explanation, added message for error responses from camera
 * 2015-9-19 - Added support for MultiAttribute Tiles
 * 2015-9-19 - Check for invalid IP Address or port and other settings
 * 2015-9-1 - Improved callback motion status update after 10 seconds
 * 2015-8-27 - Added option to reduce light sensitivity for SD cameras
 * 2015-8-24 - Fine tune movements of cameras and communication delays
 * 2015-8-24 - Fix for phantom alarm when turning on sometimes left over from previous alarm
 * 2015-8-23 - Fix for Push notification recurring alarm and improved reliability for SD Camera notifications
 * 2015-8-23 - Enabled support for Push notifications for SD cameras
 * 2015-8-23 - Removed attributes ledState and ledMode and converted to state variables
 * 2015-8-23 - Added support for SD Camera Poll Alarm notifications (push doesn't always work due to 128 character URL limit)
 * 2015-8-23 - Added support for eMail, Motion Sensitivity levels and Snap picture on motion alert for SD cameras
 * 2015-8-22 - Bugfixes for SD Foscam (MJPEG series likes 9810)
 * 2015-8-14 - Added support for Mirror and Flip for SD cameras Video orientation
 * 2015-8-14 - Added support for SD Camera Alarm push notifications
 * 2015-8-13 - Alarm notification for SD cameras is not supported yet, only for HD cameras
 * 2015-8-13 - Fixed the rearm interval to 15 seconds because the ST platform is too slow to communicate the camera and may miss the motion alarm notification
 * 2015-6-21 - Fixed issue with refresh not working
 * 2015-6-21 - Added support for mirroring/Flipping for HD cameras and support for video mirroring/flipping
 * 2015-6-19 - Added attributes ledState and ledMode to definitions
 * 2015-6-18 - Fix for tile names not being restored after pressing
 * 2015-6-17 - Added support for Motion Sensor to report motion - to be used in conjunction with the Foscam Motion Alarm Monitor since we can't poll from device code
 * 2015-6-17 - Enhanced reporting status dynamically, improved communicated reliablility, reduced verbosity of activity logs
 * 2015-6-17 - Added support for getting LED on/off status, simplified LED icons
 * 2015-6-17 - Fixed issue with HD camera's not working due to ST platform changes
 * 2015-3-28 - Fixed missing command siren and both for alarm capability, temp fix for android carousel hang, fixed issue with preset and cruisemap names breaking on android
 * 2015-2-22 - Fix for Alarm and Switch not being updated
 * 2015-2-4 - Presets show names
 * 2015-1-29 - Added options for configuring eMail, local ringer alarm, taking pictures and recording videos for motion detection
 * 2015-1-20 - Cruisemaps now show the names
 * 2015-1-20 - Added support for hostnames (public) instead of ipaddress for device
 * 2015-1-19 - Turning on the strobe function also takes a picture
 * 2015-1-19 - Support configuring motion alarm snap interval and motion sensitivity, added support for using as an Alarm and Switch/Relay Switch to enable monitoring
 *
 *  This device has the following functions:
 *    - Take a snapshot
 *    - Report a motion alarm
 *    - Toggle the infrared lights
 *    - Enable/Disable motion alarm
 *    - Go to and set preset locations
 *    - Enable cruise maps
 *    - Control PTZ
 *    - Reboot
 *    - Support for public and private hosts/ipaddresses
 *    - Support for video streams
 */
 
metadata {
	definition (name: "RBoy Foscam IP Camera", namespace: "rboy", author: "RBoy") {
		capability "Polling"
		capability "Image Capture"
        capability "Alarm"
        capability "Relay Switch"
        capability "Switch"
        capability "Refresh"
        capability "Motion Sensor"
        capability "Sensor"
        capability "Video Camera"
        capability "Video Capture"
        capability "Configuration"
        
        attribute "alarmStatus", "string"
        attribute "ledStatus",   "string"
        attribute "hubactionMode", "string"
        attribute "cruise1", "string"
        attribute "cruise2", "string"
        attribute "presetA", "string"
        attribute "presetB", "string"
        attribute "presetC", "string"
        attribute "mirrorStatus", "string"
        attribute "flipStatus", "string"
        attribute "cameraType", "string"
        attribute "alarmNotifyType", "string"
        attribute "imageDataJpeg", "string"
        attribute "codeVersion", "string"
        attribute "dhName", "string"
    
		command "alarmOn"
		command "alarmOff"
		command "toggleAlarm"

		command "toggleLED"
		command "ledOn"
		command "ledOff"
		command "ledAuto"
        
		command "left"
		command "right"
		command "up"
		command "down"
        
		command "cruisemap1"
		command "cruisemap2"
		command "stopCruise"
        
		command "preset1"
		command "preset2"
		command "preset3"
        
        command "reboot"
        command "checkMotionStatus"
        command "registerMotionCallback", ["string"]
        command "deRegisterMotionCallback"
        command "motionCallbackNotify"
        command "startVideo"
        command "setHiRes"
        command "setLowRes"
	}
    
    preferences {
        input title: "", description: "Foscam Device Handler v${clientVersion()}", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input title: "", description: "NOTE: For live streaming to work your phone needs to be able to reach your camera directly using the IP Address/URL below", displayDuringSetup: true, type: "paragraph", element: "paragraph", required: true
        input("ip", "string", title:"Camera IP Address/Public Hostname", description: "Camera IP Address or DNS Hostname", required: true, displayDuringSetup: true)
        input("port", "number", title:"Camera Port", description: "Camera Port", defaultValue: "80" , required: true, displayDuringSetup: true)
        input("username", "string", title:"Camera Username (case sensitive)", description: "Camera Username (case sensitive)", required: true, displayDuringSetup: true)
        input("password", "password", title:"Camera Password (case sensitive)", description: "Camera Password (case sensitive)", required: false, displayDuringSetup: true)
        input title: "", description: "If your camera supports Onvif (under Network in the Foscam web settings), enable it and enter the RTSP port here for live streaming (otherwise it defaults to the Camera Port above). Most cameras that have Onvif/RTSP typically use port 554", displayDuringSetup: true, type: "paragraph", element: "paragraph", required: true
        input("rtspport", "number", title:"RTSP Port", description: "RTSP Port", required: false, displayDuringSetup: true)
        input("hdcamera", "bool", title:"Enable this if the camera is a HD model (720p or higher)?", description: "Type of Camera", required: false, displayDuringSetup: true)
        input("cameraModel", "enum", title:"Select your camera model", multiple: false, defaultValue: "Other Foscam", options: ["Others":"Other Foscam","Amba":"C2/R2/FI9900P"], description: "Select Other Foscam if your camera model isn't listed here", required: true, displayDuringSetup: true)
        input("mirror", "bool", title:"Mirror", description: "Mirror Image? (Horizontal)?", required: false, displayDuringSetup: true)
        input("flip", "bool", title:"Flip", description: "Flip Image? (Vertical)?", required: false, displayDuringSetup: true)
        input title: "", description: "Configure the motion/sound detection features of the camera. NOTE: Sound detection is very sensitive on Foscam cameras", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("motionLevel", "enum", title:"Motion Detection Sensitivity Level", multiple: false, defaultValue: "Medium", options: ["Lowest","Lower","Low","Medium","High"], description: "Alarm Motion Sensitivity Level", required: true, displayDuringSetup: true)
        input("soundAlarm", "bool", title:"Enable Sound Detection", description: "Enable alarm for sound detection", defaultValue: false, required: false, displayDuringSetup: true)
        input("motionEMail", "bool", title:"Intruder Detected -> Send EMail", description: "Send e-Mail when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionSnap", "bool", title:"Intruder Detected -> Take Picture", description: "Take a picture when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionRecord", "bool", title:"Intruder Detected -> Record Video (HD cameras only)", description: "Record a video when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        input("motionRing", "bool", title:"Intruder Detected -> Turn On Built-In Camera Sound Alarm (HD cameras only)", description: "Sound local ring alarm when motion is detected", defaultValue: true, required: false, displayDuringSetup: true)
        //input("reArmInterval", "enum", title:"Intruder Detect -> Re-Arm Interval (HD cameras only)", multiple: false, defaultValue: "15s", options: ["5s","6s","7s","8s","9s","10s","11s","12s","13s","14s","15s"], description: "Alarm Motion Snap Interval in seconds", required: true, displayDuringSetup: true)
        input title: "", description: "Configure the following 2 options only if your camera supports enabling/disabling Video motion and (Human) PIR motion detection separately", displayDuringSetup: false, type: "paragraph", element: "paragraph"
        input("motionAlarmEnable", "bool", title:"Enable Video Motion Detection", description: "Enable camera video motion detection", defaultValue: true, required: false, displayDuringSetup: false)
        input("pirAlarmEnable", "bool", title:"Enable PIR Motion Detection", description: "Enable human motion detection", defaultValue: true, required: false, displayDuringSetup: false)
        input title: "", description: "Enter the preset and cruise map names as configured on your camera. NOTE: This is only for HD cameras (720p or higher)", displayDuringSetup: true, type: "paragraph", element: "paragraph"
		input("preset1", "text", title: "Preset 1 (HD cameras only)", description: "Name of your first preset position", defaultValue: "", displayDuringSetup: true)
		input("preset2", "text", title: "Preset 2 (HD cameras only)", description: "Name of your second preset position", defaultValue: "", displayDuringSetup: true)
		input("preset3", "text", title: "Preset 3 (HD cameras only)", description: "Name of your third preset position", defaultValue: "", displayDuringSetup: true)
		input("cruisename1", "text", title: "Cruise Map 1 (HD cameras only. Non-HD cameras will default to Horizontal.)", description: "Name of your first cruise map", defaultValue: "Horizontal", displayDuringSetup: true)
		input("cruisename2", "text", title: "Cruise Map 2 (HD cameras only. Non-HD cameras will default to Vertical.)", description: "Name of your second cruise map", defaultValue: "Vertical", displayDuringSetup: true)
        input title: "", description: "SmartTiles MJPEG Streaming\nIf your HD camera supports MJPEG, Enable this option to view the live stream in SmartTiles using this URL: http://IPADDRESS:PORT/cgi-bin/CGIStream.cgi?cmd=GetMJStream&usr=USERNAME&pwd=PASSWORD", displayDuringSetup: true, type: "paragraph", element: "paragraph"
        input("mjpeg", "bool", title:"Enable MJPEG Stream (HD Cameras only)", description: "MJPEG Streaming", required: false, displayDuringSetup: true)
        input("lightCompensation", "bool", title:"Compensate for sudden light changes (SD cameras only)", description: "Reduce Motion Alarms due to sudden changes in light", defaultValue: true, required: false, displayDuringSetup: false)
        input("detectionArea", "string", title:"(Advanced) Enter the motion detection area parameters (Optional, leave empty if unsure)", defaultValue: "area0=1023&area1=1023&area2=1023&area3=1023&area4=1023&area5=1023&area6=1023&area7=1023&area8=1023&area9=1023", description: "Enter the parameters to use for motion detection area without the leading or trailing &, leave blank for default full screen detection", required: false, displayDuringSetup: false)
        input title: "", description: "THE BELOW SETTINGS ONLY APPLY TO THE NEW FOSCAM AMBARELLA CAMERAS (e.g. C2, R2, FI9900P)", displayDuringSetup: false, type: "paragraph", element: "paragraph", required: true
        input("disableMotionDetect", "bool", title:"Disable Motion Detection", description: "Disable regular camera motion detection", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanMotionDetect", "bool", title:"Enable Human Detection", description: "Detect human presence", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanSensitivity", "number", title:"Human Detection Sensitivity", description: "Sensitivity for detecting humans", defaultValue: "100", range: "0..100", required: false, displayDuringSetup: false)
        input("humanCountEnable", "bool", title:"Enable People Counting", description: "Count humans detected", defaultValue: false, required: false, displayDuringSetup: false)
        input("humanBoxingEnable", "bool", title:"Enable Bounding Box", description: "Detect human boundaries", defaultValue: false, required: false, displayDuringSetup: false)
        input("uploadCloud", "bool", title:"Intruder Detected -> Upload to Cloud", description: "Upload picture and recording to Foscam cloud", defaultValue: false, required: false, displayDuringSetup: false)
        input("pushFoscamPhoneApp", "bool", title:"Intruder Detected -> Push message to Foscam app", description: "Push notification to Foscam native phone app", defaultValue: false, required: false, displayDuringSetup: false)
	}

	tiles(scale: 2) {
		multiAttributeTile(name:"summary", type: "generic", width: 6, height: 4){
			tileAttribute ("device.alarmStatus", key: "PRIMARY_CONTROL") {
              attributeState "off", label: "Detect Off", action: "toggleAlarm", icon: "st.camera.dlink-hdpan", backgroundColor: "#FFFFFF", nextState:"..."
              attributeState "on", label: "Detect On", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#79b821", nextState:"..."
              attributeState "alarm", label: "Motion", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#53A7C0", nextState:"..."
              attributeState "error", label: "ERROR", action: "", icon: "st.camera.dlink-hdpan",  backgroundColor: "#FF3333", nextState:""
              attributeState "...", label: "...", action:"", nextState:"..."
            }
            tileAttribute ("device.ledStatus", key: "SECONDARY_CONTROL") {
                attributeState "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState:"..."
                attributeState "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState:"..."
                attributeState "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState:"..."
                attributeState "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState:"..."
                attributeState "...", label: "...", action:"", nextState:"..."
            }
        }
        
        multiAttributeTile(name: "videoPlayer", type: "videoPlayer", width: 6, height: 4) {
            tileAttribute("device.camera", key: "CAMERA_STATUS") {
				attributeState("on", label: "Active", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#79b821", defaultState: true)
				attributeState("off", label: "Inactive", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#ffffff")
				attributeState("restarting", label: "Connecting", icon: "st.camera.dlink-hdpan", backgroundColor: "#53a7c0")
				attributeState("unavailable", label: "Click here to connect", icon: "st.camera.dlink-hdpan", action: "", backgroundColor: "#F22000")
			}

			tileAttribute("device.errorMessage", key: "CAMERA_ERROR_MESSAGE") {
				attributeState("errorMessage", label: "", value: "", defaultState: true)
			}

			tileAttribute("device.camera", key: "PRIMARY_CONTROL") {
				attributeState("on", label: "Active", icon: "st.camera.dlink-hdpan", backgroundColor: "#79b821")
				attributeState("off", label: "Inactive", icon: "st.camera.dlink-hdpan", backgroundColor: "#ffffff", defaultState: true)
				attributeState("restarting", label: "Connecting", icon: "st.camera.dlink-hdpan", backgroundColor: "#53a7c0")
				attributeState("unavailable", label: "Click here to connect", icon: "st.camera.dlink-hdpan", backgroundColor: "#F22000")
			}

            tileAttribute ("device.ledStatus", key: "SECONDARY_CONTROL") {
                attributeState "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState:"..."
                attributeState "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState:"..."
                attributeState "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState:"..."
                attributeState "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState:"..."
                attributeState "...", label: "...", action:"", nextState:"..."
            }

            tileAttribute("device.startLive", key: "START_LIVE") {
				attributeState("live", action: "startVideo", defaultState: true)
			}

			tileAttribute("device.stream", key: "STREAM_URL") {
				attributeState("activeURL", defaultState: true)
			}

			/*tileAttribute("device.profile", key: "STREAM_QUALITY") {
				attributeState("hi", label: "Hi-Res", action: "setHiRes", defaultState: true)
				attributeState("low", label: "Low-Res", action: "setLowRes")
			}*/ // TODO: No profiles for now, lowRes MJPEG is not 100% stable so only use hiRes for now

			/*tileAttribute("device.betaLogo", key: "BETA_LOGO") {
				attributeState("betaLogo", label: "", value: "", defaultState: true)
			}*/
		}
		
        standardTile("alarmStatusA", "device.alarmStatus", width: 2, height: 2, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
            state "off", label: "Off", action: "toggleAlarm", icon: "st.camera.dlink-hdpan", backgroundColor: "#FFFFFF", nextState:"..."
            state "on", label: "On", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#79b821", nextState:"..."
            state "alarm", label: "Motion", action: "toggleAlarm", icon: "st.camera.dlink-hdpan",  backgroundColor: "#53A7C0", nextState:"..."
            state "error", label: "ERROR", action: "", icon: "st.camera.dlink-hdpan",  backgroundColor: "#FF3333", nextState:""
            state "...", label: "...", action:"", nextState:"..."
        }
        
        carouselTile("cameraDetails", "device.image", width: 4, height: 2) { }

		standardTile("take", "device.image", width: 2, height: 2, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
			state "take", label: "Take", action: "Image Capture.take", icon: "st.camera.camera", backgroundColor: "#FFFFFF", nextState:"taking"
			state "taking", label:'Taking', action: "", icon: "st.camera.take-photo", backgroundColor: "#53a7c0"
			state "image", label: "Take", action: "Image Capture.take", icon: "st.camera.camera", backgroundColor: "#FFFFFF", nextState:"taking"
		}

        standardTile("ledStatus", "device.ledStatus", width: 2, height: 2, canChangeIcon: false, inactiveLabel: true, canChangeBackground: false) {
          state "autoOn", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#79b821", nextState:"..."
          state "autoOff", label: "Auto", action: "toggleLED", icon: "st.lights.multi-light-bulb-on", backgroundColor: "#9ceaf0", nextState:"..."
          state "on", label: "On", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#79b821", nextState:"..."
          state "off", label: "Off", action: "toggleLED", icon: "st.lights.multi-light-bulb-off", backgroundColor: "#FFFFFF", nextState:"..."
          state "...", label: "...", action:"", nextState:"..."
        }

		standardTile("preset1", "device.presetA", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "preset1", label: '${currentValue}', action: "preset1", icon: ""
		}

		standardTile("preset2", "device.presetB", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "preset2", label: '${currentValue}', action: "preset2", icon: ""
		}

		standardTile("preset3", "device.presetC", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "preset3", label: '${currentValue}', action: "preset3", icon: ""
		}
        
		standardTile("cruisemap1", "device.cruise1", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "cruisemap1", label: '${currentValue}', action: "cruisemap1", icon: ""
		}

		standardTile("cruisemap2", "device.cruise2", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "cruisemap2", label: '${currentValue}', action: "cruisemap2", icon: ""
		}
 
 		standardTile("stopcruise", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "stopcruise", label: "Stop Cruise", action: "stopCruise", icon: ""
		}

		standardTile("left", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "left", label: "left", action: "left", icon: "st.thermostat.thermostat-left"
		}

		standardTile("right", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "right", label: "right", action: "right", icon: "st.thermostat.thermostat-right"
		}

		standardTile("up", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "up", label: "up", action: "up", icon: "st.thermostat.thermostat-up"
		}

		standardTile("down", "device.image", width: 1, height: 1, canChangeIcon: false, canChangeBackground: false, decoration: "flat") {
			state "down", label: "down", action: "down", icon: "st.thermostat.thermostat-down"
		}

		standardTile("stop", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
			state "stop", label: "", action: "stopCruise", icon: "st.sonos.stop-btn"
		}

        standardTile("refresh", "device.status", width: 2, height: 2, inactiveLabel: false, decoration: "flat") {
        	state "refresh", action:"refresh.refresh", icon:"st.secondary.refresh"
        }
        
        standardTile("blank", "device.image", width: 1, height: 1, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
        standardTile("blank2x", "device.image", width: 2, height: 2, canChangeIcon: false,  canChangeBackground: false, decoration: "flat") {
        	state "blank", label: "", action: "", icon: "", backgroundColor: "#FFFFFF"
        }
        
        standardTile("reboot", "device.image", width: 1, height: 1, inactiveLabel: false, decoration: "flat") {
      		state "reboot", label: "reboot", action: "reboot", icon: "st.quirky.spotter.quirky-spotter-plugged"
    	}

        main "summary", "videoPlayer"
        details(["ledStatus", "refresh", "alarmStatusA", "cameraDetails", "take", "videoPlayer", "blank", "up", "blank", "preset1", "preset2", "preset3", "left", "stop", "right", "cruisemap1", "cruisemap2", "stopcruise", "blank", "down", "blank", "blank", "reboot", "blank"])
	}
}

import groovy.json.JsonSlurper

// Milli seconds delay between sending commands
private int delayInterval() {
 return 800
}

def initialize() {
    log.trace "Initialize called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        response(refresh())
	} catch (e) {
		log.warn "initialize() threw $e"
	}
}

// TODO: For some users, BUG WITH SMARTTHINGS PLATFORM, EVERYTIME A SMARTAPP CALLS A DEVICE FUNCTION, THIS UPDATED FUNCTION IS ALSO CALLED!!! IT ALSO CAUSES RANDOM ISSUES LIKE EVENT STATE BEING LOST FOR SOME USERS
/*def updated() {
	log.trace "Update called settings: $settings"
	try {
		if (!state.init) {
			state.init = true
		}
        response(refresh()) // Get the updates and configure the video streams
	} catch (e) {
		log.warn "updated() threw $e"
	}
}*/

//START VIDEO
// Thank you for the tip @ahndee
mappings {
    path("/getInHomeURL") {
        action:
            [GET: "getInHomeURL"]
    }
    
    path("/getOutHomeURL") {
        action:
            [GET: "getOutHomeURL"]
    }
}

def getInHomeURL() {
    log.trace "Called getInHomeURL, returning $state.uri"
    state.uri ? [InHomeURL: state.uri]: null // return null if it's not initialized otherwise ST app crashes
}

def getOutHomeURL() {
    log.trace "Called getOutHomeURL, returning $state.uri"
    state.uri ? [OutHomeURL: state.uri] : null // return null if it's not initialized otherwise ST app crashes
}

def setHiRes() {
    log.debug "Setting hi resolution stream"
    if (hdcamera) {
        log.debug "Enabling HiRes Stream type 0 for HD Camera"
        hubGet("cmd=setMainVideoStreamType&streamType=0") // TODO: Should we always use stream 0?
        
        log.trace "Using h.264 main stream for high bitrate streaming"
        state.uri = "rtsp://${(username)}:${(password)}@${ip}:${rtspport ?: port}/videoMain" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
    } else {
        log.trace "Setting up high resolution stream for SD camera"
        state.uri = "http://${ip}:${port}" + "/videostream.cgi?" + "user=${username}&pwd=${password}" + "&resolution=32" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
    }

    sendEvent(name: "profile", value: "hi", displayed: false)
}

private void setSubStreamingMode(mjpegEnable) {
    log.debug "Setting sub streaming mode for Camera (MJPEG mode enables SmartTiles compatibility) : ${mjpegEnable ? "MJPEG" : "h.264"}"
    hubGet("cmd=setSubStreamFormat&format=" + (mjpegEnable ? "1" : "0")) // 1 for MJPEG, 0 for H.264 stream http://foscam.us/forum/how-to-fetch-snapshots-and-mjpeg-stream-on-hd-cameras-t4328.html
}

def setLowRes() {
    log.debug "Setting low resolution stream"
    if (hdcamera) { // The newer HD cameras can operate as MPEG or h.264
        setSubStreamingMode(mjpeg) // Configure h.264 or MJPEG for sub streaming video. MJPEG required for compatibility with SmartTiles
        
        if (mjpeg) {
            log.trace "Using MJPEG for low bitrate streaming"
            state.uri = "http://${ip}:${port}" + "/cgi-bin/CGIStream.cgi?cmd=GetMJStream&" + "usr=${username}&pwd=${password}" // Don't URL encode the password here since it doesn't seem to work for special characters like ! with this special Video Tile
        } else {
            log.trace "Using h.264 sub stream for low bitrate streaming"
            state.uri = "rtsp://${(username)}:${(password)}@${ip}:${rtspport ?: port}/videoSub" // http://foscam.us/forum/how-to-use-rtsp-and-https-for-hd-cameras-t4926.html
        }
    } else { // Older SD cameras use MJPEG by default
        log.trace "Setting up low resolution stream for SD camera"
        state.uri = "http://${ip}:${port}" + "/videostream.cgi?" + "user=${username}&pwd=${password}" + "&resolution=8" // High resolution (640x480) is 32, low is 8 (320x240), don't URL encode the password since it doesnt work here
    }

    sendEvent(name: "profile", value: "low", displayed: false)
}

def startVideo() {
    def hiRes = (device.currentValue("profile") == "low" ? false : true) // default to hi res (since low res has issue with mjpeg)
	log.debug "Starting video streaming with ${hiRes ? "High" : "Low"} profile stream"

    log.trace "Fetching video from: ${state.uri}"
    
    if (!state.uri) {
        refresh() // Initialize the camera
    }
    
	def dataLiveVideo = [
		OutHomeURL  : state.uri, // This appears to be only one used
		InHomeURL   : state.uri, // TODO: What is this??
		ThumbnailURL: "http://cdn.device-icons.smartthings.com/camera/dlink-hdpan@2x.png",
		cookie      : [key: "key", value: "value"]
	]

    log.trace "Video settings: $dataLiveVideo"
    
	def event = [
		name           : "stream",
		value          : groovy.json.JsonOutput.toJson(dataLiveVideo).toString(),
		data		   : groovy.json.JsonOutput.toJson(dataLiveVideo),
		descriptionText: "Starting the live video stream",
		eventType      : "VIDEO",
		displayed      : false,
		isStateChange  : true
	]
    
	sendEvent(event)
}
//END START VIDEO

//TAKE PICTURE
def take() {
	log.debug("Taking Photo")
    if (rateLimitExceeded()) {
        log.warn "Too many pictures taken in too short a time, skipping request"
        return
    }
	sendEvent(name: "hubactionMode", value: "s3", displayed: false)
    if(hdcamera) {
		hubGet("cmd=snapPicture2")
    }
    else {
    	hubGet("/snapshot.cgi?")
    }
}
//END TAKE PICTURE

//SWITCH ACTIONS
def on() {
	log.debug "On requested, enabling monitoring"
    alarmOn()
}

def off() {
	log.debug "Off requested, disabling monitoring"
    alarmOff()
}
//END SWITCH ACTIONS

//ALARM ACTIONS
def both() {
	log.debug "Alarm both requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def siren() {
	log.debug "Alarm siren requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def strobe() {
	log.debug "Alarm strobe requested, enabling monitoring and taking picture"
    take()
    alarmOn()
}

def toggleAlarm() {
	log.debug "Toggling Alarm"
	if(device.currentValue("alarmStatus") == "off") {
    	alarmOn()
  	} else {
    	alarmOff()
	}
}

def alarmOn() {
	log.debug "Enabling Alarm"

	if(hdcamera) {
        if (cameraModel == "Amba") {
            delayBetween([hubGet("cmd=setMotionDetectConfig1&isEnable=${disableMotionDetect ? "0" : "1"}&isMovAlarmEnable=${motionAlarmEnable ? "1" : "0"}&isPirAlarmEnable=${pirAlarmEnable ? "1" : "0"}&snapInterval=1&linkage=${getAmbaMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&x1=0&y1=0&width1=10000&height1=10000&sensitivity1=${getMotionLevel(motionLevel)}&valid1=1&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), hubGet("cmd=setHumanDetectConfig&isEnable=${humanMotionDetect ? "1" : "0"}&sensitivity=${humanSensitivity ?: "100"}&isHumanCountEnable=${humanCountEnable ? "1" : "0"}&isHumanBoxingEnable=${humanBoxingEnable ? "1" : "0"}&linkage=${getAmbaMotionAlarmEvents()}&snapInterval=1&triggerInterval=${getReArmInterval("10s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), hubGet("cmd=setAudioAlarmConfig&isEnable=${soundAlarm ? "1" : "0"}&sensitivity=0&linkage=${getAmbaMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), poll()], delayInterval())
        } else {
            delayBetween([hubGet("cmd=setMotionDetectConfig&isEnable=1&isMovAlarmEnable=${motionAlarmEnable ? "1" : "0"}&isPirAlarmEnable=${pirAlarmEnable ? "1" : "0"}&snapInterval=1&sensitivity=${getMotionLevel(motionLevel)}&linkage=${getMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655&${getDetectionArea(detectionArea)}&1421696056773"), hubGet("cmd=setAudioAlarmConfig&isEnable=${soundAlarm ? "1" : "0"}&sensitivity=0&linkage=${getMotionAlarmEvents()}&triggerInterval=${getReArmInterval("15s")}&schedule0=281474976710655&schedule1=281474976710655&schedule2=281474976710655&schedule3=281474976710655&schedule4=281474976710655&schedule5=281474976710655&schedule6=281474976710655"), poll()], delayInterval())
        }
    }
    else {
    	delayBetween([hubGet("/set_alarm.cgi?motion_armed=1&motion_sensitivity=${getMotionLevel(motionLevel)}&motion_compensation=${lightCompensation ? "1" : "0"}&sounddetect_enabled=${soundAlarm ? "1" : "0"}&sounddetect_sensitivity=9&mail=${motionEMail ? "1" : "0"}&upload_interval=${motionSnap ? "1" : "0"}&"), poll()], delayInterval())
    }
}

def alarmOff() {
	log.debug "Disabling Alarm"

    if(hdcamera) {
        if (cameraModel == "Amba") {
            delayBetween([hubGet("cmd=setMotionDetectConfig1&isEnable=0"), hubGet("cmd=setHumanDetectConfig&isEnable=0"), hubGet("cmd=setAudioAlarmConfig&isEnable=0"), poll()], delayInterval())
        } else {
            delayBetween([hubGet("cmd=setMotionDetectConfig&isEnable=0"), hubGet("cmd=setAudioAlarmConfig&isEnable=0"), poll()], delayInterval())
        }
    }
    else {
    	delayBetween([hubGet("/set_alarm.cgi?motion_armed=0&sounddetect_enabled=0&"), poll()], delayInterval())
    }
    
}
//END ALARM ACTIONS

//LED ACTIONS
//Toggle LED's
def toggleLED() {
	log.debug("Toggle LED")

    if(hdcamera) {
        if((device.currentValue("ledStatus") == "autoOn") || (device.currentValue("ledStatus") == "autoOff")) {
            ledOn()
        } else if(device.currentValue("ledStatus") == "on") {
            ledOff()
        } else {
            ledAuto()
        }
    } else {
        ledAuto() // There is no way to get current status of LED for SD Cameras to keep it in Auto all the time
    }
}

def ledOn() {
    log.debug("LED changed to: on")
    if(hdcamera) {
	    delayBetween([hubGet("cmd=setInfraLedConfig&mode=1"), hubGet("cmd=openInfraLed"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=95&"), poll()], delayInterval())
    }
}

def ledOff() {
    log.debug("LED changed to: off")
    if(hdcamera) {
    	delayBetween([hubGet("cmd=setInfraLedConfig&mode=1"), hubGet("cmd=closeInfraLed"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=94&"), poll()], delayInterval())
    }
}

def ledAuto() {
    log.debug("LED changed to: auto")
	if(hdcamera) {
		delayBetween([hubGet("cmd=setInfraLedConfig&mode=0"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=95&"), poll()], delayInterval())
    }
}
//END LED ACTIONS

//PRESET ACTIONS
def preset1() {
	log.debug("Preset 1 Selected - ${preset1}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(preset1)}"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=31&"), poll()], delayInterval())
    }
}

def preset2() {
	log.debug("Preset 2 Selected - ${preset2}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(preset2)}"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=33&"), poll()], delayInterval())
    }
}

def preset3() {
	log.debug("Preset 3 Selected - ${preset3}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzGotoPresetPoint&name=${URLEncoder.encode(preset3)}"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=35&"), poll()], delayInterval())
    }
}
//END PRESET ACTIONS

//CRUISE ACTIONS
def cruisemap1() {
	log.debug("Cruise Map 1 Selected - ${cruisename1}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzStartCruise&mapName=${cruisename1}"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=28&"), poll()], delayInterval())
    }
}

def cruisemap2() {
	log.debug("Cruise Map 2 Selected - ${cruisename2}")
	if(hdcamera) {
		delayBetween([hubGet("cmd=ptzStartCruise&mapName=${cruisename2}"), poll()], delayInterval())
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=26&"), poll()], delayInterval())
    }
}

def stopCruise() {
	log.debug("Stop Cruise")
	if(hdcamera) {
		hubGet("cmd=ptzStopRun")
    }
    else {
    	delayBetween([hubGet("/decoder_control.cgi?command=29&"), hubGet("/decoder_control.cgi?command=27&")], 200)
    }
}
//END CRUISE ACTIONS

//PTZ CONTROLS
def left() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveLeft"), hubGet("cmd=ptzStopRun")], 1000)
    }
    else {
    	if(mirror) {
	    	hubGet("/decoder_control.cgi?command=4&onestep=1&")
        }
        else {
        	hubGet("/decoder_control.cgi?command=6&onestep=1&")
        }
    }
}

def right() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveRight"), hubGet("cmd=ptzStopRun")], 1000)
    }
    else {
    	if(mirror) {
	    	hubGet("/decoder_control.cgi?command=6&onestep=1&")
        }
        else {
        	hubGet("/decoder_control.cgi?command=4&onestep=1&")
        }
    }
}

def up() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveUp"), hubGet("cmd=ptzStopRun")], 1000)
    }
    else {
    	if(flip) {
	    	hubGet("/decoder_control.cgi?command=2&onestep=1&")
        }
        else {
        	hubGet("/decoder_control.cgi?command=0&onestep=1&")
        }
    }
}

def down() {
	if(hdcamera) { // HD Camera compensates for mirror/flip automatically
        delayBetween([hubGet("cmd=ptzMoveDown"), hubGet("cmd=ptzStopRun")], 1000)
    }
    else {
    	if(flip) {
    		hubGet("/decoder_control.cgi?command=0&onestep=1&")
        }
        else {
        	hubGet("/decoder_control.cgi?command=2&onestep=1&")
        }
    }
}
//END PTZ CONTROLS

//REBOOT
def reboot() {
	log.debug "Rebooting camera"
	if(hdcamera) {
		hubGet("cmd=rebootSystem")
    }
    else {
    	hubGet("/reboot.cgi?&" + getLogin())
    }
}
//END REBOOT

def configure() {
    log.trace "Configuration called"
    
    def hiRes = (device.currentValue("profile") == "low" ? false : true) // default fall back hi resolution since low resolution has issues with mjpeg and ST app compatibility
	log.debug "Configuring video streaming for ${hiRes ? "High" : "Low"} Resolution stream"

    if (mjpeg && hdcamera) {
        log.debug "Enabling Camera MJPEG sub streaming mode for SmartTile compatibility"
        setSubStreamingMode(mjpeg)
    }
    
    if (hiRes) {
        setHiRes()
    } else {
        setLowRes()
    }
}

def refresh() {
	log.trace "Refresh called. Settings -> $settings"
    state.cameraHost = null // Reset it to force a lookup

    rateLimitExceeded("", true) // Reset rate allowance

    configure() // Configure the camera
	poll()
}

def poll() {
	log.trace "Poll called"
    
	//Update the tiles names
    sendEvent(name: "cruise1", value: "${(cruisename1 == null ) ? "" : cruisename1} Cruise", isStateChange: true, displayed: false)
    sendEvent(name: "cruise2", value: "${(cruisename2 == null ) ? "" : cruisename2} Cruise", isStateChange: true, displayed: false)
    sendEvent(name: "presetA", value: "Preset ${(preset1 == null ) ? "" : preset1}", isStateChange: true, displayed: false)
    sendEvent(name: "presetB", value: "Preset ${(preset2 == null ) ? "" : preset2}", isStateChange: true, displayed: false)
    sendEvent(name: "presetC", value: "Preset ${(preset3 == null ) ? "" : preset3}", isStateChange: true, displayed: false)
    sendEvent(name: "cameraType", value: "${hdcamera ? "HD" : "SD"}", displayed: false)
    sendEvent(name: "alarmNotifyType", value: "${hdcamera ? "Pull" : "Push"}", displayed: false) // Only SD camera support Push notifications

    def cmds = [] // we can only have one delayBetween, put them all together in the right order

	//Poll Motion Alarm Status and IR LED Mode and device status
    if (hdcamera) {
        // Get the device, LED and Mirror status first
        cmds << hubGet("cmd=getDevState") // Motion detection/alarm status
        cmds << hubGet("cmd=getInfraLedConfig")
        cmds << hubGet("cmd=getMirrorAndFlipSetting")
        //cmds << hubGet("cmd=getAudioAlarmConfig") // not required for now
        //cmds << hubGet("cmd=getMotionDetectConfig${cameraModel == "Amba" ? "1" : ""}") // not required for now, we have everything we need
        //if (cameraModel == "Amba") {
        	//cmds << hubGet("cmd=getHumanDetectConfig") // not required for now, we have everything we need
        //}

		// Enable/Disable Mirror
        if (mirror && (device.currentValue("mirrorStatus") != "1")) {
            log.debug "Enabling video mirroring"
            cmds << hubGet("cmd=mirrorVideo&isMirror=1")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        }
        else if (!mirror && (device.currentValue("mirrorStatus") != "0")) {
            log.debug "Disabling video mirroring"
            cmds << hubGet("cmd=mirrorVideo&isMirror=0")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        }

		// Enable/Disable Flip
        if (flip && (device.currentValue("flipStatus") != "1")) {
            log.debug "Enabling video flipping"
            cmds << hubGet("cmd=flipVideo&isFlip=1")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        }
        else if (!flip && (device.currentValue("flipStatus") != "0")) {
            log.debug "Disabling video flipping"
            cmds << hubGet("cmd=flipVideo&isFlip=0")
            cmds << hubGet("cmd=getMirrorAndFlipSetting")
        }
	}
    else {
        // Get all the settings first
        cmds << hubGet("/get_status.cgi?") // Motion Detection Status
        cmds << hubGet("/get_params.cgi?") // Alarm Status
    	cmds << hubGet("/get_camera_params.cgi?") // Mirror and flip status

		// Enable/Disable Mirror
        def enableMirror = false
        def enableFlip = false
        if (mirror && (device.currentValue("mirrorStatus") != "1")) {
            log.debug "Enabling video mirroring"
            enableMirror = true
        }
        else if (!mirror && (device.currentValue("mirrorStatus") != "0")) {
            log.debug "Disabling video mirroring"
            enableMirror = false
        }

		// Enable/Disable Flip
        if (flip && (device.currentValue("flipStatus") != "1")) {
            log.debug "Enabling video flipping"
            enableFlip = true
        }
        else if (!flip && (device.currentValue("flipStatus") != "0")) {
            log.debug "Disabling video flipping"
            enableFlip = false
        }

		if (enableMirror && enableFlip) {
            cmds << hubGet("/camera_control.cgi?param=5&value=3&")
			cmds << hubGet("/get_camera_params.cgi?")
        } else if (!enableMirror && enableFlip) {
            cmds << hubGet("/camera_control.cgi?param=5&value=1&")
			cmds << hubGet("/get_camera_params.cgi?")
        } else if (enableMirror && !enableFlip) {
            cmds << hubGet("/camera_control.cgi?param=5&value=2&")
			cmds << hubGet("/get_camera_params.cgi?")
        } else if (!enableMirror && !enableFlip) {
            cmds << hubGet("/camera_control.cgi?param=5&value=0&")
			cmds << hubGet("/get_camera_params.cgi?")
        }
    }

    //log.trace "Executing -> ${cmds.inspect()}"
    delayBetween(cmds, delayInterval())
}

private getLogin() {
	if(hdcamera) {
    	return "usr=${URLEncoder.encode(username)}&pwd=${URLEncoder.encode(password)}&"
    }
    else {
    	return "user=${URLEncoder.encode(username)}&pwd=${URLEncoder.encode(password)}"
    }
}

private hubGet(def apiCommand) {
    sendEvent([name: "codeVersion", value: clientVersion()]) // Save client version for parent app
    sendEvent([name: "dhName", value: "Foscam Device Handler"]) // Save DH Name for parent app

	// Check if we have a hostname and if so convert to IP Address
    if (state.cameraHost != ip) { // check if the IP/Host has changed
        if (!isIPAddress(ip)) {
            //log.trace "Converting hostname $ip to IP Address before continuing"
            state.ipAddress = convertHostnameToIPAddress(ip)
            log.trace "Got IPAddress=${state.ipAddress} for hostname=$ip"
        } else {
            state.ipAddress = ip
            log.trace "Using IPAddress=${state.ipAddress}"
        }
        state.cameraHost = ip // We've completed the above successfully, cache it to improve performance
    } else {
        log.trace "Using cached IPAddress=${state.ipAddress}"
    }
    
	//Setting Network Device Id
    def iphex = convertIPtoHex(state.ipAddress)
    def porthex = convertPortToHex(port)
    device.deviceNetworkId = "$iphex:$porthex"
    //log.trace "Device Network Id set to ${iphex}:${porthex}"

	//log.trace("Executing hubaction on " + getHostAddress(state.ipAddress))

    def uri = ""
    if (hdcamera) {
    	uri = "/cgi-bin/CGIProxy.fcgi?" + getLogin() + apiCommand
	}
    else {
    	uri = apiCommand + getLogin()
    }
    
	boolean doHubAction = false
    if (isPublicIPAddress(state.ipAddress)) { // If we are working with a public IP address then use httpGet from ST cloud to public IP, it's faster and more reliable (doesn't depend on loopback)
        log.trace "Sending httpGet command -> http://${getHostAddress(ip)}$uri"
        try {
            httpGet("http://${getHostAddress(ip)}$uri") { response -> parseHttpGetResponse(response) }
        } catch (Exception e) {
            log.warn "Unable to connect to host ${getHostAddress(ip)}, Error: $e"
            log.debug "Falling back to hubAction and retrying command"
            doHubAction = true // lets fall back and retry, hubAction works for both private and public ip addresses
        }
    } else { // If we are using local IP Address, use hubAction, the only way to communicate from hub to Camera.
    	doHubAction = true
    }
    
    if (doHubAction) {
        log.trace "Sending hubAction command -> http://${getHostAddress(state.ipAddress)}$uri"
        def hubAction = new physicalgraph.device.HubAction(
            method: "GET",
            path: uri,
            headers: [HOST:getHostAddress(state.ipAddress)]
        )

        // If we have a picture then extract it and store it and set the hubAction mode accordingly
        if (device.currentValue("hubactionMode") == "s3") {
            hubAction.options = [outputMsgToS3:true]
            sendEvent(name: "hubactionMode", value: "local", displayed: false)
        }
        sendHubCommand(hubAction)
    }
}

def parseHttpGetResponse(response) {
    log.trace "Received response from camera to httpGet, headers=${response.headers.'Content-Type'}, status=$response.status"
    if (response.status == 200) {
        if(response.headers.'Content-Type'.contains("image/jpeg")) { // If we have a picture store it directly
            if(response.data) {
                def image = response.data

                // Send the image to an App who wants to consume it via an event as a Base64 String - NOTE: Disabled for now since ST has put a limitation on this which is causing trouble with the carousel
                //def bytes = image.buf
                //log.debug "JPEG Data Size: ${bytes.size()}"
                //String str = bytes.encodeBase64()
                //sendEvent(name: "imageDataJpeg", value: str, displayed: false, isStateChange: true)
                sendEvent(name: "imageDataJpeg", value: "", displayed: false, isStateChange: false) // Wipe it clean so it empties any old data

                // Now save it to the S3 cloud, so this in the end since it removes the data from the object leaving it empty
                log.info "Saving picture to SmartThings"
                storeImage(getPictureName(), image)
            } else {
                log.warn "Received an empty response from camera, expecting a JPEG image"
            }
        } else { // Otherwise process the camera response codes
            def body = response.data.getText()
            //log.trace "httpGet -> ${body}"
            processResponse(body)
        }
    } else {
        log.error "Error response from host ${getHostAddress(state.ipAddress)}, HTTP Response code: $response.status"
    }
}

//Parse events into attributes (this function is called when we are using hubAction. i.e. for a LAN IP address)
def parse(String description) {
	log.trace "Received response from Camera to hubAction"
    
    def descMap = parseDescriptionAsMap(description)
    //log.trace "${descMap.inspect()}"
    
    // Check if its a picture and process it
	if (descMap["bucket"] && descMap["key"]) {
    	log.info "Saving picture to SmartThings"
		putImageInS3(descMap)
	} else if (descMap["headers"] && descMap["body"]) { // Otherwise check camera response
        def body = new String(descMap["body"].decodeBase64())
	    //log.trace "Body -> ${body}"
		processResponse(body)
	}
}


def parseDescriptionAsMap(description) {
	description.split(",").inject([:]) { map, param ->
		def nameAndValue = param.split(":")
		map += [(nameAndValue[0].trim()):nameAndValue[1].trim()]
	}
}

def putImageInS3(map) {
    //log.trace "${map.inspect()}"

	try {
		def imageBytes = getS3Object(map.bucket, map.key + ".jpg")

		if(imageBytes)
		{
			def s3ObjectContent = imageBytes.getObjectContent()
			def image = new ByteArrayInputStream(s3ObjectContent.bytes)
            if (image) {
                // Send the image to an App who wants to consume it via an event as a Base64 String
                def bytes = image.buf
                //log.debug "JPEG Data Size: ${bytes.size()}"
                String str = bytes.encodeBase64()
                sendEvent(name: "imageDataJpeg", value: str, displayed: false, isStateChange: true)

                // Now save it to the S3 cloud, so this in the end since it removes the data from the object leaving it empty
                log.info "Saving picture to SmartThings"
                storeImage(getPictureName(), image)
            } else {
                log.warn "No picture returned, nothing to save"
            }
        } else {
            log.warn "No picture content, nothing to save"
        }
	}
	catch(Exception e) {
		log.error "Error processing image, Error: $e"
	}
	finally {
		//Explicitly close the stream
		if (s3ObjectContent) { s3ObjectContent.close() }
	}
}

// Process the response from the camera
def processResponse(String body) {
    //log.trace body
    if(hdcamera) {
        def statusVars = new XmlSlurper(false,false,true).parseText(body?.trim()?.replaceFirst("^([\\W]+)<","<")) // Some cameras create a malformed XML so ignore BOM's and extra characters before the start of the XML
        //log.trace "Vars -> ${statusVars}"

        // Check the result value for the command sent
        switch (statusVars.result) {
            case "0":
                //log.warn "Camera responded with result ${statusVars.result} -> ALL's GOOD, THIS IS JUST A DEBUG" // Do nothing, this is good!
                break

            case "-1":
                log.error "Camera responded with result ${statusVars.result} -> CGI request string format error, your Username or Password may contain invalid character. The only allowed special characters are ~!@^*()_"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-2":
                log.error "Camera responded with result ${statusVars.result} -> Invalid username or password. Check your Username and Password (BOTH are case sensitive)"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-3":
                log.error "Camera responded with result ${statusVars.result} -> Access denied"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-4":
                log.error "Camera responded with result ${statusVars.result} -> CGI execution failed"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-5":
                log.error "Camera responded with result ${statusVars.result} -> Timeout"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-6":
                log.error "Camera responded with result ${statusVars.result} -> Reserved error"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-7":
                log.error "Camera responded with result ${statusVars.result} -> Unknown error"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            case "-8":
                log.error "Camera responded with result ${statusVars.result} -> Reserved error"
            	sendEvent(name: "alarmStatus", value: "error")
                break

            default:
                log.error "Camera responded with result ${statusVars.result} -> Unknown error"
            	sendEvent(name: "alarmStatus", value: "error")
                break
        }

        def motionAlarmDetect = "$statusVars.motionDetectAlarm" // $statusVars.isEnable is used with getMotionDetectConfig
        def humanAlarmDetect = "$statusVars.humanDetectAlarmState" // Amba foscam (C2, R2, FI9900P)
        def soundAlarmDetect = "$statusVars.soundAlarm" // Sounds alarm
        //log.warn "motionAlarmDetect=$motionAlarmDetect, humanAlarmDetect=$humanAlarmDetect, soundAlarmDetect=$soundAlarmDetect"
        def ledM = "$statusVars.mode"
        def ledS = "$statusVars.infraLedState"
        def flipS = "$statusVars.isFlip"
        def mirrorS = "$statusVars.isMirror"

        // Get mirror and flip settings
        if (mirrorS?.trim() != "") {
            log.info "Polled: Mirror status $mirrorS"
            sendEvent(name: "mirrorStatus", value: mirrorS, displayed: false)
        }
        if (flipS?.trim() != "") {
            log.info "Polled: Flip status $flipS"
            sendEvent(name: "flipStatus", value: flipS, displayed: false)
        }

        //Get Motion Alarm Status
        if(motionAlarmDetect == "2" || soundAlarmDetect == "2" || humanAlarmDetect == "2") {
            log.info("Polled: ${motionAlarmDetect == 2 ? "Motion" : (humanAlarmDetect == 2 ? "Human Motion" : "Sound Motion")} Alarm Alert!!")
            sendEvent(name: "alarmStatus", value: "alarm")
            sendEvent(name: "alarm", value: "both")
            sendEvent(name: "switch", value: "on")
            sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected ${motionAlarmDetect == 2 ? "motion" : (humanAlarmDetect == 2 ? "human motion" : "sound motion")}")
        } else if(motionAlarmDetect == "1" || soundAlarmDetect == "1" || humanAlarmDetect == "1") {
            log.info("Polled: ${motionAlarmDetect == 1 ? "Motion" : (humanAlarmDetect == 1 ? "Human Motion" : "Sound Motion")} Alarm On")
            sendEvent(name: "alarmStatus", value: "on")
            sendEvent(name: "alarm", value: "both")
            sendEvent(name: "switch", value: "on")
            sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName ${motionAlarmDetect == 1 ? "motion" : (humanAlarmDetect == 1 ? "human motion" : "sound motion")} stopped")
        } else if(motionAlarmDetect || soundAlarmDetect || humanAlarmDetect) {
            log.info("Polled: Motion Alarm Off")
            sendEvent(name: "alarmStatus", value: "off")
            sendEvent(name: "alarm", value: "off")
            sendEvent(name: "switch", value: "off")
            sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion detection off")
        }
        
        //Get IR LED Mode
        if(ledM == "0") {
            log.info("Polled: LED Mode Auto")
            state.ledMode = "auto" // this is an internal variable to track the LED mode
        }
        else if(ledM == "1") {
            log.info("Polled: LED Mode Manual")
            state.ledMode = "manual" // this is an internal variable to track the LED mode
        }

        //Get IR LED Status
        //log.trace "Mode " + state.ledMode + " State " + state.ledState
        if(ledS == "1") {
            log.info("Polled: LED On")
            state.ledState = "on" // this is an internal variable to track the LED state
        }
        else if(ledS == "0") {
            log.info("Polled: LED Off")
            state.ledState = "off" // this is an internal variable to track the LED state
        }

        //Update LED Status
        if (state.ledState == "on") {
            if (state.ledMode == "auto") {
                state.ledState = "reset"
                state.ledMode = "reset"
                sendEvent(name: "ledStatus", value: "autoOn", displayed: false)
                log.trace "ledStatus " + device.currentValue("ledStatus")
            }
            else if (state.ledMode == "manual") {
                state.ledState = "reset"
                state.ledMode = "reset"
                sendEvent(name: "ledStatus", value: "on", displayed: false)
                log.trace "ledStatus " + device.currentValue("ledStatus")
            }
        }
        else if (state.ledState == "off") {
            if (state.ledMode == "auto") {
                state.ledState = "reset"
                state.ledMode = "reset"
                sendEvent(name: "ledStatus", value: "autoOff", displayed: false)
                log.trace "ledStatus " + device.currentValue("ledStatus")
            }
            else if (state.ledMode == "manual") {
                state.ledState = "reset"
                state.ledMode = "reset"
                sendEvent(name: "ledStatus", value: "off", displayed: false)
                log.trace "ledStatus " + device.currentValue("ledStatus")
            }
        }
    } else {
        // Check for an error in the result value of the command sent
        if (body.find("401 Unauthorized")) {
            log.error "Camera responded with an 401 Unauthorized error. Check you Username and Password (BOTH are case sensitive). Error -> ${body}"
            return
        } else if (body.find("illegal params")) {
            log.error "Camera responded with an error. Likely caused by an invalid Username or Password, check you Username and Password (BOTH are case sensitive). Error -> ${body}"
            return
        }

        // Don't update events here since often the order of commands get mixed up, capture the states first
        if(body.find("alarm_motion_armed=0")) {
            log.info("Polled: Motion Alarm Off")
            state.sdAlarmArmed = "Off"
        }
        else if(body.find("alarm_motion_armed=1")) { // only check for "on" status when alarm is not active
            log.info("Polled: Motion Alarm On")
            state.sdAlarmArmed = "On"
        }

        if(body.find("alarm_status=1")) { // Check for active alarm
            log.info("Polled: Motion Alarm Alert!!")
            state.sdAlarmStatus = "Alarm"
        } else if(body.find("alarm_status=0")) {
            state.sdAlarmStatus = "None"
        }

        // Check our state now and update the events
        log.trace "Motion: ${state.sdAlarmStatus}, Armed: ${state.sdAlarmArmed}"
        if (state.sdAlarmArmed == "Off") { // First priority, if we're in off state then turn it off
            sendEvent(name: "alarmStatus", value: "off")
            sendEvent(name: "alarm", value: "off")
            sendEvent(name: "switch", value: "off")
            sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion stopped")
            state.sdAlarmStatus = "None" // Since they are 2 different registers we can have have Alarm on but monitoring off, force Alarm off if monitoring is off
        } else if ((state.sdAlarmArmed == "On") && (state.sdAlarmStatus == "Alarm")) { // Next priority Alarm 
            sendEvent(name: "alarmStatus", value: "alarm")
            sendEvent(name: "alarm", value: "both")
            sendEvent(name: "switch", value: "on")
            sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
        } else if ((state.sdAlarmArmed == "On") && (state.sdAlarmStatus == "None")) { // If not in alarm check for On
            sendEvent(name: "alarmStatus", value: "on")
            sendEvent(name: "alarm", value: "both")
            sendEvent(name: "switch", value: "on")
            sendEvent(name: "motion", value: "inactive", descriptionText: "$device.displayName motion stopped")
        }

        if(body.find("alarm_http=0")) {
            log.info("Polled: Motion Alarm Callback Notification Disabled")
        } else if(body.find("alarm_http=1")) {
            def callbackURL = (body =~ ".*?alarm_http_url='(.*?)'")[0][1]
            log.info("Polled: Motion Alarm Callback Notification Enabled with URL $callbackURL")
        }

        // Get mirror and flip settings
        if (body.find("flip=0")) {
            log.info "Polled: Flip Status 0, Mirror Status 0"
            sendEvent(name: "mirrorStatus", value: "0", displayed: false)
            sendEvent(name: "flipStatus", value: "0", displayed: false)
        } else if (body.find("flip=1")) {
            log.info "Polled: Flip status 1, Mirror Status 0"
            sendEvent(name: "mirrorStatus", value: "0", displayed: false)
            sendEvent(name: "flipStatus", value: "1", displayed: false)
        } else if (body.find("flip=2")) {
            log.info "Polled: Flip status 0, Mirror status 1"
            sendEvent(name: "mirrorStatus", value: "1", displayed: false)
            sendEvent(name: "flipStatus", value: "0", displayed: false)
        } else if (body.find("flip=3")) {
            log.info "Polled: Flip status 1, Mirror status 1"
            sendEvent(name: "mirrorStatus", value: "1", displayed: false)
            sendEvent(name: "flipStatus", value: "1", displayed: false)
        }

        //The API does not provide a way to poll for LED status on 8xxx series at the moment, just keep it in autoOff mode
        sendEvent(name: "ledStatus", value: "autoOff", isStateChange: true, displayed: false)
    }
}

def checkMotionStatus() {
	log.debug "Checking motion alarm status"

	//Poll Motion Alarm Status
    if (hdcamera) {
        hubGet("cmd=getDevState") // Motion/Alarm status
    } else {
    	delayBetween([hubGet("/get_status.cgi?"), hubGet("/get_params.cgi?")], delayInterval()) // Motion Detection Status, Alarm Status
    }
}

def registerMotionCallback(callbackURL)
{
	if (device.currentValue("alarmNotifyType") == "Pull") {
    	log.error "This cameras doesn't support callback URL, this should not be called"
    } else {
		log.debug "Registering motion detection callback URL -> $callbackURL"
        delayBetween([hubGet("/set_alarm.cgi?http=1&http_url=$callbackURL&"), poll()], delayInterval())
    }
}

def deRegisterMotionCallback()
{
	if (device.currentValue("alarmNotifyType") == "Pull") {
    	log.error "This camera doesn't support deregistering callback URL, this should not be called"
    } else {
		log.debug "DeRegistering motion detection callback"
        delayBetween([hubGet("/set_alarm.cgi?http=0&"), poll()], delayInterval())
    }
}

def motionCallbackNotify()
{
    log.info("Callback Notify: Motion Alarm Alert!!")
    sendEvent(name: "alarmStatus", value: "alarm")
    sendEvent(name: "alarm", value: "both")
    sendEvent(name: "switch", value: "on")
    sendEvent(name: "motion", value: "active", descriptionText: "$device.displayName detected motion")
    delayBetween(["delay 1000", poll()], 10000) // Polling will set the mode back to on or off (current mode), wait 10 seconds before turning off the alarm
}

def testTrace() {
	log.trace "*** Calling test trace ***"
}

private getPictureName() {
  def pictureUuid = java.util.UUID.randomUUID().toString().replaceAll('-', '')
  "image" + "_$pictureUuid" + ".jpg"
}

private getHostAddress(host) {
	return "${host}:${port}"
}

private String convertIPtoHex(ipAddress) {
	// Check for valid IPv4 address, ST doesn't support IPv6 yet
    if (!isIPAddress(ipAddress)) {
        log.error "Invalid IP Address $ipAddress, check your settings!"
    }
    
	try {
        String hex = ipAddress.tokenize( '.' ).collect {  String.format('%02x', it.toInteger() ) }.join()  // thanks to @pstuart
        return hex
    } catch (Exception e) {
        log.error "Invalid IP Address $ipAddress, check your settings! Error: $e"
    }
}

private String convertPortToHex(port) {
	if (!port || (port == 0)) {
    	log.error "Invalid port $port, check your settings!"
    }
    
    try {
        String hexport = port.toString().format('%04x', port.toInteger() )   // thanks to @pstuart
        return hexport
    } catch (Exception e) {
        log.error "Invalid port $port, check your settings! Error: $e"
    }
}

private String getDetectionArea(area) {
	log.trace "User entered detection:$area"
    
    if (area?.trim()) {
    	// Remove any trailing or leading & if entered accidentally
        area = area.replaceAll("^&+", "") // Leading &
    	area = area.replaceAll("&+\$", "") // Trailing &
        return area
    } else {
    	return "area0=1023&area1=1023&area2=1023&area3=1023&area4=1023&area5=1023&area6=1023&area7=1023&area8=1023&area9=1023" // Default is full frame detection
    }
}

private String getMotionLevel(motion) {
	log.trace "Motion Level is $motion"

	String retVal = ""
    
    switch (motion) {
    	case "Lowest":
        	if (hdcamera)
        		retVal = "4"
        	else
                retVal = "9"
            break
            
    	case "Lower":
        	if (hdcamera)
        		retVal = "3"
        	else
                retVal = "7"
            break
            
    	case "Low":
        	if (hdcamera)
        		retVal = "0"
        	else
                retVal = "5"
            break
            
    	case "Medium":
        	if (hdcamera)
        		retVal = "1"
        	else
                retVal = "3"
            break
            
    	case "High":
        	if (hdcamera)
        		retVal = "2"
        	else
                retVal = "0"
            break
            
		default:
        	log.warn "Invalid motion level $motion, check your settings, reverting to default"
            
        	if (hdcamera)
        		retVal = "1"
        	else
                retVal = "3"
            break
    }
    
    log.trace("Motion value is $retVal")
    
    return retVal
}

private String getReArmInterval(interval) {
	log.trace("Trigger/ReArm internal is $interval")

	String retVal = ""
    
    switch (interval) {
    	case "5s":
        	retVal = "0"
            break
            
    	case "6s":
        	retVal = "1"
            break
            
    	case "7s":
        	retVal = "2"
            break
            
    	case "8s":
        	retVal = "3"
            break
            
    	case "9s":
        	retVal = "4"
            break
            
    	case "10s":
        	retVal = "5"
            break
            
    	case "11s":
        	retVal = "6"
            break
            
    	case "12s":
        	retVal = "7"
            break
            
    	case "13s":
        	retVal = "8"
            break
            
    	case "14s":
        	retVal = "9"
            break
            
    	case "15s":
        	retVal = "10"
            break
            
		default:
        	log.warn "Invalid trigger interval $interval, check your settings, reverting to default 10"
            
        	retVal = "10"
            break
    }

	log.trace("Snap interval value is $retVal")
    
    return retVal
}

private String getMotionAlarmEvents() {
	int ret = 0 // Default nothing to enable
    
    if (motionRing) {
    	ret |= 0x1 // Enable local ringer
	    log.trace "Enabled motion ringer, $ret"
    }
    
    if (motionEMail) {
    	ret |= 0x2 // Enable sending eMails
	    log.trace "Enabled motion eMail, $ret"
    }
    
    if (motionSnap) {
    	ret |= 0x4 // Enable taking pictures
	    log.trace "Enabled motion snap pictures, $ret"
    }
    
    if (motionRecord) {
    	ret |= 0x8 // Enabling taking a video recording
	    log.trace "Enabled motion video recording, $ret"
    }
    
    log.trace "Motion alarm config value $ret"

    return ret.toString()
}

private String getAmbaMotionAlarmEvents() {
	int ret = 0 // Default nothing to enable
    
    if (motionRing) {
    	ret |= 0x1 // Enable local ringer
	    log.trace "Enabled motion ringer, $ret"
    }
    
    if (motionEMail) {
    	ret |= 0x2 // Enable sending eMails
	    log.trace "Enabled motion eMail, $ret"
    }
    
    if (motionSnap) {
    	ret |= 0x4 // Enable taking pictures
	    log.trace "Enabled motion snap pictures, $ret"
    }
    
    if (motionRecord) {
    	ret |= 0x8 // Enabling taking a video recording
	    log.trace "Enabled motion video recording, $ret"
    }
    
    if (uploadCloud) {
    	ret |= (0x20 | 0x40) // Enabling uploading photo and recording to cloud
	    log.trace "Enabled uploading photo and recording to cloud, $ret"
    }
    
    if (pushFoscamPhoneApp) {
    	ret |= 0x80 // Enabling pushing message to native foscam app
	    log.trace "Enabled push message to native foscam phone app, $ret"
    }
    
    log.trace "Motion alarm config value $ret"

    return ret.toString()
}

private boolean isIPAddress(String ipAddress)
{
    try
    {
         String[] parts = ipAddress.split("\\.")
         if (parts.length != 4) {
         	return false
         }
         for (int i = 0; i < 4; ++i)
         {
             int p = Integer.parseInt(parts[i])
             if (p > 255 || p < 0) {
             	return false
             }
         }
         return true
    } catch (Exception e)
    {
        return false
    }
}

private String convertHostnameToIPAddress(hostname) {
    def params = [
        uri: "http://dns.google.com/resolve?name=" + hostname,
        contentType: 'application/json'
    ]

    def retVal = null

    try {
        retVal = httpGet(params) { response ->
            log.trace "Request was successful, data=$response.data, status=$response.status"
            //log.trace "Result Status : ${response.data?.Status}"
            if (response.data?.Status == 0) { // Success
                for (answer in response.data?.Answer) { // Loop through results looking for the first IP address returned otherwise it's redirects
                    //log.trace "Processing response: ${answer}"
                    if (isIPAddress(answer?.data)) {
                        log.trace "Hostname ${answer?.name} has IP Address ${answer?.data}"
                        return answer?.data // We're done here (if there are more ignore it, we'll use the first IP address returned)
                    } else {
                        log.trace "Hostname ${answer?.name} redirected to ${answer?.data}"
                    }
                }
            } else {
                log.warn "DNS unable to resolve hostname ${response.data?.Question[0]?.name}, Error: ${response.data?.Comment}"
            }
        }
    } catch (Exception e) {
        log.warn("Unable to convert hostname to IP Address, Error: $e")
    }

    //log.trace "Returning IP $retVal for Hostname $hostname"
    return retVal
}

// Check if an ipAddress is a public ip address
private boolean isPublicIPAddress(String ipAddress) {
    try {
    	// Check for private IP Addresses
        // 0.255.255.255  (0/8 prefix) (all local)
        // 127.255.255.255  (127/8 prefix) (loopback)
        // 10.255.255.255  (10/8 prefix)
        // 172.31.255.255  (172.16/12 prefix)
        // 192.168.255.255 (192.168/16 prefix)
        // 169.254.255.255 (169.254/16 prefix) (link local)
        // Between 224.0.0.1 and 239.255.255.255 (multicast addresses)
    	if (ipAddress.find(/(^0\.)|(^127\.)|(^10\.)|(^172\.1[6-9]\.)|(^172\.2[0-9]\.)|(^172\.3[0-1]\.)|(^192\.168\.)|(^169\.254\.)|(^22[4-9]\.)|(^23[0-9]\.)/)) {
            log.trace "IPAddress $ipAddress is a private IP Address"
            return false
        } else {
            log.trace "IPAddress $ipAddress is a public IP Address"
            return true
        }
    } catch (Exception e) {
    	log.error "Invalid IPAddress $ipAddress"
        return false
    }
}

// Rate Limit to 10 Transactions per 60 seconds
private rateLimitExceeded(def x = "", def reset = false) {
    def retVal = false
    def rate = 10 // unit: transactions
    def per  = 60 * 1000 // unit: milliseconds
    
    if (reset || !state."allowance${x}") {
        state."allowance${x}" = rate // unit: transactions
        log.trace "Initializing Allowance $x: ${state."allowance${x}"}"
        if (reset) {
            return false
        }
    }
    if (reset || !state."last_check${x}") {
        state."last_check${x}" = now() // Unit: milliseconds
        log.trace "Initializing Last Check $x: ${new Date(state."last_check${x}")}"
        if (reset) {
            return retVal
        }
    }

    def current = now() // Unit: milliseconds
    def time_passed = current - state."last_check${x}" // Unit: milliseconds
    log.trace "Passed $x: ${time_passed/1000} seconds"
    state."last_check${x}" = current
    state."allowance${x}" = (state."allowance${x}" + (time_passed * (rate / per))) as BigDecimal // Patch as ST doesn't support float yet
    if (state."allowance${x}" > rate) {
        state."allowance${x}" = rate // throttle
    }
    if (state."allowance${x}" < 1) {
        retVal = true // discard transaction
        // Disable the next line if you don't want to penalize repeat offenders and allow it to reset after the duration (per)
        state."allowance${x}" = state."allowance${x}" - 1 // Continue to deplete the count to block continuous offenders
    } else {
        retVal = false // continue with transactions
        state."allowance${x}" = state."allowance${x}" - 1
    }
    
    log.trace "Allowance $x: ${state."allowance${x}"}, Last Check: ${new Date(state."last_check${x}")}"
    
    return retVal
}